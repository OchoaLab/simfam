% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geno_last_gen_admix_recomb.R
\name{geno_last_gen_admix_recomb}
\alias{geno_last_gen_admix_recomb}
\title{Simulate an admixed family efficiently with founders with LD}
\usage{
geno_last_gen_admix_recomb(
  anc_haps,
  bim,
  map,
  G,
  fam,
  ids,
  founders_anc,
  loci_on_cols = FALSE,
  missing_vals = c("", 0)
)
}
\arguments{
\item{anc_haps}{A named list that maps the code used for each ancestry to its haplotype matrix.
Each of the haplotype matrices the argument \code{haps} passed to \code{\link[=pop_recomb]{pop_recomb()}}, namely is a regular matrix or \code{BEDMatrix} object of haplotype values, one row per locus, one column per haplotype (half individual), or transposed if \code{loci_on_cols = TRUE} and for \code{BEDMatrix} objects.
Here, these values must be numeric (recommended are zeroes and ones, indicating absence or presence of reference allele).}

\item{bim}{The table of variants of \code{haps}, which is a data.frame/tibble with at least two columns: \code{chr} (must be numeric between 1 and the maximum chromosome in \code{map} below for map to work) and \code{pos} (base pair position, usually an integer).}

\item{map}{The genetic map, a list of chromosomes each of which is a data.frame/tibble with columns \code{pos} for base pair position and \code{posg} for genetic position.}

\item{G}{Number of generations since most recent common ancestor of population (to multiply standard recombination rate)}

\item{fam}{The pedigree data.frame, in plink FAM format.
Only columns \code{id}, \code{pat}, and \code{mat} are required.
\code{id} must be unique and non-missing.
Founders must be present, and their \code{pat} and \code{mat} values must be missing (see below).
Non-founders must have both their parents be non-missing.
Parents must appear earlier than their children in the table.}

\item{ids}{A list containing vectors of IDs for each generation.
All these IDs must be present in \code{fam$id}.
If IDs in \code{fam} and \code{ids} do not fully agree, the code processes the IDs in the intersection, which is helpful when \code{fam} is pruned but \code{ids} is the original (larger) set.}

\item{founders_anc}{a named vector that maps every founder haplotype (the names of this vector) to its ancestry code.
Ancestry codes must match the codes used in \code{anc_haps} above.
Founder haplotypes are the founder individual IDs from the pedigree (values in \code{ids[[1]]}) appearing twice, suffixed with "_pat" and "_mat", respectively (so the parents of the founders are unadmixed, though founders be first generation admixed this way).}

\item{loci_on_cols}{If \code{TRUE}, \code{haps} has loci on columns and individuals on rows; if \code{FALSE} (default), loci are on rows and individuals on columns.
If \code{haps} is a \code{BEDMatrix} object, \code{loci_on_cols} is ignored (set automatically to \code{TRUE} internally).}

\item{missing_vals}{The list of ID values treated as missing.
\code{NA} is always treated as missing.
By default, the empty string ('') and zero (0) are also treated as missing (remove values from here if this is a problem).}
}
\value{
A named list with three elements:
\itemize{
\item \code{X}: the genotype matrix of the focal individuals, as returned by \code{\link[=recomb_geno_inds]{recomb_geno_inds()}}.
\item \code{Ls}: a list, mapping each ancestry to its matrix of local ancestry dosages, as returned by \code{\link[=recomb_admix_inds]{recomb_admix_inds()}}.
\item \code{haplos}: a phased version of the haplotypes and local ancestries of the focal individuals, structured as nested lists, as returned by \code{\link[=recomb_haplo_inds]{recomb_haplo_inds()}}.
}
}
\description{
This function in essence combines \code{\link[=pop_recomb]{pop_recomb()}} to simulate founders of known ancestries with LD (following a Li-Stephens-like model), draws recombination breaks of focal last-generation descendants from the specified pedigree using \code{\link[=recomb_last_gen]{recomb_last_gen()}}, and their genomes from the founders variants using \code{\link[=recomb_haplo_inds]{recomb_haplo_inds()}}.
However, since a limited portion of founder sequences is actually inherited, the simulation is made much more efficient by simulating only those subsequences that were inherited, which saves time, and utilizing sparse matrices, which saves memory too.
See below for a more detailed algorithm.
}
\details{
This function wraps around several exported package functions to achieve its objectives, which are roughly grouped into the following 4 phases.
Phase 1 simulates recombination in the family without explicit sequences.
In particular, it initializes the founder haplotype structure (without variants yet) using \code{\link[=recomb_init_founders]{recomb_init_founders()}}, then simulates recombination breaks along the pedigree and identifies all the founder haplotype blocks in the focal individuals using \code{\link[=recomb_last_gen]{recomb_last_gen()}}, and maps recombination breaks in cM to basepairs using \code{\link[=recomb_map_inds]{recomb_map_inds()}}.
Phase 2 reorganizes this data to identify the unique founder blocks that were inherited, first by making the data tidy with \code{\link[=tidy_recomb_map_inds]{tidy_recomb_map_inds()}}, then applying \code{\link[=recomb_founder_blocks_inherited]{recomb_founder_blocks_inherited()}}.
Phase 3 initializes founder haplotypes using sparse matrices from the package \code{Matrix}, and draws inherited founder subsequences according to their known ancestries and using the Li-Stephens-like haplotype model of \code{\link[=pop_recomb]{pop_recomb()}}.
Phase 4 constructs the genotype matrices of focal individuals using the haplotypes of the founders drawn in phase 3 and the known origin of focal blocks from founders from phase 1, first constructing this data at the phased haplotype level with \code{\link[=recomb_haplo_inds]{recomb_haplo_inds()}}, reencoding as unphased genotypes using \code{\link[=recomb_geno_inds]{recomb_geno_inds()}}, and constructing the corresponding local ancestry dosages using \code{\link[=recomb_admix_inds]{recomb_admix_inds()}}.
}
\examples{
library(tibble)

# simulate random haplotypes for example
# this toy data has 10 SNPs per chromosome, in fixed positions for simplicity
bim <- tibble( chr = rep( 1 : 22, each = 10 ), pos = rep( (1:10) * 1e6, 22 ) )
# and random haplotype data to go with this
n_ind_hap <- 10
m_loci <- nrow( bim )
# NOTE ancestry labels can be anything but must match `founders_anc` below
anc_haps <- list(
    'AFR' = matrix( rbinom( m_loci * n_ind_hap, 1L, 0.5 ), nrow = m_loci, ncol = n_ind_hap ),
    'EUR' = matrix( rbinom( m_loci * n_ind_hap, 1L, 0.2 ), nrow = m_loci, ncol = n_ind_hap )
)

# now simulate a very small family with one individual, 2 parents, 4 implicit grandparents
data <- fam_ancestors( 2 )
fam <- data$fam
ids <- data$ids
# select ancestries for each of the 4 grandparents / founder haplotypes (unadmixed)
founders_anc <- c('AFR', 'AFR', 'AFR', 'EUR')
# set names of founders with _pat/mat, needed to match recombination structure
# order is odd but choices were random so that doesn't matter
names( founders_anc ) <- c(
    paste0( ids[[1]], '_pat' ),
    paste0( ids[[1]], '_mat' )
)

# this performs the simulation!
data <- geno_last_gen_admix_recomb( anc_haps, bim, recomb_map_hg38, 10, fam, ids, founders_anc )
# this is the genotype matrix for the one admixed individual
data$X
# the corresponding local ancestry dosage matrices
# names match input labels
data$Ls$AFR
data$Ls$EUR
# if desired, a more complete but more complicated structure holding phased haplotypes
# and phased local ancestry information
data$haplos

}
\seealso{
\code{\link[=recomb_init_founders]{recomb_init_founders()}}, \code{\link[=recomb_last_gen]{recomb_last_gen()}}, \code{\link[=recomb_map_inds]{recomb_map_inds()}}, \code{\link[=tidy_recomb_map_inds]{tidy_recomb_map_inds()}}, \code{\link[=recomb_founder_blocks_inherited]{recomb_founder_blocks_inherited()}}, \code{\link[=pop_recomb]{pop_recomb()}}, \code{\link[=recomb_haplo_inds]{recomb_haplo_inds()}}, \code{\link[=recomb_geno_inds]{recomb_geno_inds()}}, \code{\link[=recomb_admix_inds]{recomb_admix_inds()}}.
}
